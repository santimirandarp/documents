<html><header><link rel="stylesheet" href="../assets/css/index.css"></header>
  <body>

  <h1>Variables, Symlinks, Aliases</h1>
  <h2>Setting a Variable in Linux</h2>
  <p>Every now and then we have to set up a variable. There are many ways to do it.</p>
  <ol>
    <li><code>MYVAR=name</code> sets up a session variable (useful on the same terminal). ex:
      LINUX='cd ~/a/b/c' and executed as $LINUX.</li>
    <li>for user-scoped <code>~/.bashrc</code>, <code>~/.profile/</code> etc. <code>export MYVAR=name</code>.</li> 
    <li>System wide, persitent can be set on <code>/etc/profile</code> as <code> export MYVAR=name</code>
    </li>
    <!--not sure why export is needed-->
    <li>System Wide, persistent are also set on <code>/etc/environment/</code>
    </li>
  </ol>
  <p> Some system wide stuff can be found at <code>/etc/bash.bashrc</code>. This file is overwritten by user-scoped bash config file (bashrc). I've changed the way it outputs the PS1 which is the prompt, so it doesn't prints the absolute path, but only the last folder (pwd helps with the full path f it is needed). This way the prompt is not overloaded of words. </p>
  <h3>Sources</h3>
  <p>See https://www.tutorialspoint.com/unix/unix-environment.htm for help.</p>
  <p>This type of variables are used by other programs. For example, when typing <b>:edit</b> in <em> broot
  </em> the program invokes the $EDITOR variable that should be set to <code>/usr/bin/vim</code> or some editor. 
  </p>
  <p>The command <b>env</b> outputs all the environment variables. set prints all the shell variables.</p>
  <h2 id="add-a-program-to-path">Add a program to $PATH</h2>
  <p>A very useful system variable is <b>PATH</b>. It stores, directories where the system looks for a command everytime bash is executed.</p>
  <p>`echo $PATH` prints a <b>list</b> of directories it stores. To add one, edit <b>.bashrc</b> by editing it like so: `PATH=/directory/to/add:$PATH`</p>
  <p>On sass, for example, for global installing, the package can be downloaded from github and then the file added to the path, where the path points to the binary/program/executable. A similar installation is using `npm install -g sass`</p>

  <h2>Links</h2>
<p>
   <b>Hard link</b> is essentially a second entry in the file system pointing to the same data. If you create a hard link to a file, there is no sense in which one of the links is the "original" file and the other is a link. Change one, changes both.
</p>
<p> <b>Soft link</b> is a separate file which points to another file via its path, not to the pointer. If you delete a softlink with "rm" you are deleting the link, not the thing it points to. To create a soft link (hard links are not common), use `ln -s source dist`. Source is the file towards dist will point. If we change the file name, or location, it won't work anymore. To remove a soft link just remove the file. We can check is something is a softlink by listing with the long flag, using `ln -l`, and it will be obvious if it's a symlink.</p>
<p><b>Alias</b> is like a softlink but even if we change the file name, it will still work. It does not create and visible file, and it allows much more functionality than a link (like executing commands). Type `alias` to see all aliases, `alias name=command` to create one and `unalias aliasname` to delete. For example, I have `~/gits/documents/html/linux` to the alias <b>linux</b>. Rename the file to linux2, and the alias will still work, but not the symlink.</p>
<p>A common alias sometimes included in the .bashrc by default is `alias ..=cd ..`. There are many useful ones we can create just for our particular use case.</p>
<p>Normally, I use only aliases either for changing dirs (cd) or some recurrent, simple commands. For more complex commands we need bash functions. If we are working with many directories deep into the directory-tree, and we don't remember the names, we can set a few symlinks on our home directory.</p>

<h2>Details</h2>

<p>When commands is executed three files are open: stdin(0), stdout(1) and stderr(2).  Also, an exit code is generated **but no output**. It is accessed as $?, print using echo $?.  Counter intuitive: 0 sucessful, unsucessful.</p>
<p>We can use the exit code in conditionals:</p>

```
ls bash_aliases && echo 'find it!' || echo 'didnt find it!'
[ -n $VARIABLE ] && echo 'exists'
```
<p>Output redirection: redirection of anything appearing on the terminal to a file: firefox-developer 2 > /dev/null</p>
<p>Processes: fg, bg, C-z: firefox-developer & # the ampersand sets it as a bg process.</p>

<script src="../assets/js/index.js"></script></body></html>
