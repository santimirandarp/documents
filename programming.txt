Variables: name for a piece of information. We set it and afterwards access it with the name.

Bash:
string="my string"
array=("elements" *.txt "globs")
echo ${string} # this could be problematic if string has a dash - cause will be interpreted as an option flag.
# also, if the string starts with a glob (like *) will be impliying something we don't want. (unless we want globbing).
echo "${string}" is the correct way.
printf is another way to print out stuff.

Python
string = "my string"
array= ["the", "comma", "separated list", "now", string, "strings"]
object={"key":"value", "key2":"pairs} #access using object["key"], returns value.

Javascript:
ES6 are scoped. const can not be reassigned, but objects are allowed to mutate.

let thiswordbe="my variable"
const array=[1,2,3,"four"]
let object={noquotes:"for singlewords", "quotes for": "non single words", "optional":"always fine to use quotes"}


loops
Bash

for element in "${array[@]}"
do 
#comands here
done
A few useful bits:
"${array[@]}" makes element="${array[i]}" each time.
"${!array[@]}" makes element= array index each time.


Javascript
(many ways)

for(let i=0; i<array.length; i++){
//commands here.
}
array.forEach(callback)
const array=[1,2,3,4,5]

functions Javascript

Function Statements/Declarations
function name(){}

Function Expressions
let thisone = function [name](){

}
    Anonymoust Functions
    IIFE
    Arrow Functions.

Python and Javascript

built-in functions (methods) and properties.


Some handy pieces of code for Bash


Handy methods

Js: push
Py: append


CONSTRUCTORS, Javascript.

Constructors are functions that create new objects { }

function Bird(name) {
  this.name = name;
  this.color = "blue";
  this.numLegs = 2;
}

Then everytime we call this function, we create a new bird :-)
The values inside all called Own Properties, but it's not all there really is.

They are technically functions, but...
1. write the name capitalized,
2. use the word 'this'
3. don't normally return a value, but define props and vals.

A instance of B: instance means, was A created by B? 

Prototypes: property shared between all instances of an object, 
for example balls:"round". Prototype is an object appended to the constructor. 
And prototypes are inherited, so always Constructor.protoype is inherited from Object.prototype
In the Father object prototype there are methods shared between all instances. For example, 
string.prototype contains a length, etc. etc. Whenever we want a function or property that should 
be on every String, then chances are high that if it exists, ti will be in the prototype.

We sometimes find String.prototype...because it is shared between all instances of String object. Benefit: we do not define same props again and again for different calls of the constructor.

Own properties are properties defined in the constructor function, not in the prototype.

In the same way, when using classes, if we want a property or method to be shared between all instances 
of the class, then we define className.prototype = {...}. Though in this case, functions can be defined out of the constructor but still inside the class, and I'm not sure what role this plays.

The this.prop in a constructor function, will overwrite (literally) anything in the prototype. So we have to be careful there. The same thing in a Constructor.prototype (we are re defining) 
as prototypes for the object are just inherited from the constructor. 

Javascript engine looks for properties in the object, then in the prototype, and then in the Object Class.

Setting up prototype individually like MyCOnstructor.prototype.length=8 isn't a problem. Setting up MyConstructor.prototype={length:8} will re set the prototype object, and one property is missed forever, the Constructor. So we have to set it up again!!

Writing an equivalent Constructor  and Class
function Animal(specie, genre){
    this.specie = specie;
    this.genre = genre;
}
Animal.prototype = {constructor:Animal, 
fullName:this.specie + ' ' + this.genre}
let myAnimal = new Animal("je", "je")

class Animal2{
constructor(specie, genre){
    this.specie = specie;
    this.genre = genre; }}
//we dont need to declare the constructor when using classes.
Animal2.prototype = {
fullName:this.specie + ' ' + this.genre}
let myAnimal2 = new Animal2("je", "je")

console.log(myAnimal, myAnimal2)

SUPERTYPES


CLASSES

Class Declaration
class Name {
constructor(optional variables) {

this.variable1 = variablename
this.variable2 = variablename2

}
method1 name(){}
method2 name2(){}
}

Class Expression
let Name = class optionalName{

//same stuff
}


Neither class declarations nor class expressions are hoisted, so they have to be declared 
before we use them.

Methods and constructors are called members, and they are written inside the {} called body here.

constructor(){} is a special method that creates the object when we call let a = new Name()

constructor(){} has to be unique, another method with this name will clash.

a constructor can use the super() keyword to call the constructor of a parent class
