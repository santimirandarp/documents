<h1 id="rcc-react-core-concepts">RCC: React Core Concepts.</h1>
<blockquote>
<p>Break the UI into basic, meaningful parts. Those become your Components.</p>
</blockquote>
<h2 id="mixing-html-and-js">Mixing HTML and JS</h2>
<ul>
<li>We write normal HTML as a return value of functions. </li>
<li>In the HTML write any JS but between  { js here }. </li>
<li>Out of the HTML tags write normal js.</li>
</ul>
<h3 id="html-differences">HTML differences</h3>
<ul>
<li>All attributes are camelCase. className, onClick.
to render a component.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="language-javascript">from react import React
from react-dom import ReactDOM;
const insertThis  = &quot;but good&quot;
const JSX = (&lt;div id=&quot;myDiv&quot;&gt;&lt;h1 className=&quot;reddish&quot;&gt; The little {insertThis} document&lt;/h1&gt;&lt;/div&gt;)
ReactDOM.render(JSX, document.getElementById(&quot;root&quot;)) </code></pre>
<p><em>const JSX</em> is assigned to this native react notation, JSX.</p>
<h3 id="reacts-flow">React&#39;s Flow</h3>
<ol>
<li>Runs all js</li>
<li>Turns components into html</li>
<li>Puts the result into the html document.</li>
</ol>
<h3 id="render">Render</h3>
<p>JSX we write will be rendered to the HTML page, inside an element with an id. Example <code>ReactDOM.render(&lt;Component/&gt;, getElementById(&quot;id&quot;)&gt;</code>. We can run React in the whole site or just parts.  </p>
<p>Details of this will be understood by examples. </p>
<hr>
<h2 id="components">Components</h2>
<p>This is the main character of React. </p>
<p><em>JSX</em> code can be created using variables, functions or classes. The last 2 are called Components. Functions are <strong>stateless functional components</strong>; Classes can be stateless or stateful. Stateful components define <code>this.state = {}</code> in the <code>constructor()</code> of the class. More on it in later.</p>
<ul>
<li>Components can be exported and imported as normal javascript. </li>
</ul>
<p>Class components are classes. Clases contain a <code>constructor</code>, and inside an optional <code>super</code>, to the constructor of the parent component. It&#39;s equivalent to setting a prototype using constructors.</p>
<h2 id="import-export">Import Export</h2>
<pre><code class="language-javascript">//child.js
import React from react
function Component(){
let JSX = &lt;ul&gt;&lt;li&gt;Mooae&lt;/li&gt;&lt;li&gt;Ha Ha&lt;/li&gt;&lt;/ul&gt;
return JSX
}
default export Component</code></pre>
<pre><code class="language-javascript">//parent.js
import React from react
import Component from &#39;./child&#39;

function ParentComponent(){
let JSX = &lt;div&gt;&lt;p&gt;Parent&lt;/p&gt;&lt;Component/&gt;&lt;/div&gt;
}</code></pre>
<hr>
<h2 id="properties">Properties</h2>
<p>No easier way than an example. For functional components:</p>
<pre><code class="language-javascript">function Name(props){
return (&lt;ul&gt;&lt;li&gt;props.value&lt;/li&gt;&lt;/ul&gt;)
}
&lt;Name key={value}/&gt;</code></pre>
<p>Any other parameter in the invocation <code>&lt;Name key1={val1} key2={val2}/&gt;</code>
will be passed as <code>props = {key1:val1, key:val2}</code></p>
<p>The actual name &#39;props&#39; is irrelevant. if we write <code>Name(julioCessar){...julioCessar.key}</code> it will be the same. It&#39;s just a best practice.</p>
<p>For class components the <em>invocation is the same</em> but inside the class we use:</p>
<pre><code class="language-javascript">class Name{
constructor(){
super()
...
}
render(){return &lt;a href=&#39;hi.com&#39;/&gt;this.props.key1&lt;/a&gt;}
}</code></pre>
<h2 id="states">States</h2>
<ul>
<li><p>When react detects that <code>this.state</code> has changed, it re-renders the component.</p>
</li>
<li><p>State shouldn&#39;t be modified as: this.state.key = &#39;new value&#39;</p>
</li>
<li><p>State should be modified using setState({new state here})</p>
</li>
<li><p>Onle the <strong>initial value</strong> of state is given in the constructor.</p>
<pre><code class="language-javascript">class MyStatefulComponent extends React.Component{
  constructor(props){
      super(props);
      this.state = { posts:&quot;allpostsHere&quot;}
  }
  render() {
  const myposts = this.state.posts
  const JSX=(&lt;div&gt;
              &lt;h2&gt;New Posts&lt;/h2&gt;
              &lt;ul&gt;&lt;li&gt; We can render all posts like this: {this.state.posts}&lt;/li&gt;
              &lt;li&gt; Or we can render like this {myposts}&lt;/li&gt;
              &lt;li&gt;Second method pollutes less the markup&lt;/li&gt;
              &lt;/ul&gt;
              &lt;/div&gt;)
              return JSX
  }
}</code></pre>
</li>
<li><p>Stateless functions and stateless components just do not have this &#39;state&#39; object. </p>
</li>
<li><p>We pass state from parent to children using props (couldn&#39;t be easier).</p>
</li>
</ul>
<hr>
<h2 id="some-cool-ideas">Some Cool Ideas</h2>
<p>From reactjs.org:</p>
<blockquote>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be extracted to a separate component.</p>
</blockquote>
<blockquote>
<p>The only place where you can assign this.state is the constructor.</p>
</blockquote>
<p>This implies that <code>setState({prop:this.state...})</code> is wrong and that <code>let this.state  = this.state + 1</code> is also wrong. So now we now how to use state.</p>
<h2 id="react-core-concepts">React Core Concepts</h2>
<ul>
<li>Top Level Stateful component, and then functional, stateless children.</li>
<li>Parent affects child by passing state through props</li>
<li>A method defined in the parent is inherited to children (class&#39; body =  prototype) </li>
<li>A parent&#39;s method can be invoked in the children to change parent&#39;s state.</li>
<li>A method in the children is invoked just using the method&#39;s name. Example <code>&lt;Child onClick={this.handleClick}/&gt;</code></li>
<li>An example that is not an event handler is <Child electroprop={this.electrofn}/> and then using this.prop in class components or just props.electronprop(parameters) to the functional component.</li>
<li>for methods == normal functions, binding is necessary. for methods==arrow functions no binding necessary (but there downsides probably).</li>
</ul>
<h3 id="design-paradigm">Design Paradigm</h3>
<pre><code>                    -------------pass state as prop-----&gt; 
    Parent(stateful)                                      children(stateless)
                    &lt;------------use method of parent----</code></pre>
<h2 id="wait-where-do-i-write-my-js">Wait, where do I write my JS?</h2>
<ol>
<li><p>Remember we have class components and function components. We can write fn in the <strong>class body</strong>, sort of prototype. </p>
</li>
<li><p>Inside the render method <strong>before the return value</strong> or inside the <strong>HTML tags</strong>. Not as pure JS but as JSX. </p>
</li>
<li><p>In <strong>built-in methods</strong>. Those are also in the class body: <code>ComponentDidMount()</code> etc. These run at specific times.</p>
</li>
</ol>
<hr>
